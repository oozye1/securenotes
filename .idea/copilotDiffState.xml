<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/co/uk/doverguitarteacher/securenotesaug20th/NoteEditScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/co/uk/doverguitarteacher/securenotesaug20th/NoteEditScreen.kt" />
              <option name="originalContent" value="package co.uk.doverguitarteacher.securenotesaug20th&#10;&#10;import android.content.Context&#10;import android.graphics.Bitmap&#10;import android.graphics.BitmapFactory&#10;import android.net.Uri&#10;import android.widget.Toast&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.result.PickVisualMediaRequest&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.asImageBitmap&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.input.KeyboardType&#10;import androidx.compose.ui.text.input.PasswordVisualTransformation&#10;import androidx.compose.ui.unit.dp&#10;import androidx.core.content.FileProvider&#10;import androidx.fragment.app.FragmentActivity&#10;import androidx.navigation.NavController&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import java.io.File&#10;import java.util.UUID&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun NoteEditScreen(&#10;    navController: NavController,&#10;    viewModel: NoteViewModel,&#10;    noteId: Int?&#10;) {&#10;    val context = LocalContext.current as FragmentActivity&#10;    val coroutineScope = rememberCoroutineScope()&#10;    val isNewNote = noteId == null&#10;&#10;    val title by viewModel.editNoteTitle.collectAsState()&#10;    val content by viewModel.editNoteContent.collectAsState()&#10;    val imageUri by viewModel.editNoteImageUri.collectAsState()&#10;    val existingNote by viewModel.editNoteExistingData.collectAsState()&#10;    val tempCameraUri by viewModel.tempCameraImageUri.collectAsState()&#10;&#10;    var isEncrypted by remember(existingNote) { mutableStateOf(existingNote?.isEncrypted ?: false) }&#10;    var decryptedBitmap by remember { mutableStateOf&lt;Bitmap?&gt;(null) }&#10;    var showPinDialog by remember { mutableStateOf(false) }&#10;    var showDeleteDialog by remember { mutableStateOf(false) }&#10;    var pinAction by remember { mutableStateOf(PinAction.ENCRYPT) }&#10;&#10;    // Add a state to track decrypted image bytes&#10;    var decryptedImageBytes by remember { mutableStateOf&lt;ByteArray?&gt;(null) }&#10;&#10;    LaunchedEffect(Unit) {&#10;        viewModel.loadNoteForEdit(noteId)&#10;    }&#10;&#10;    val photoPickerLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.PickVisualMedia(),&#10;        onResult = { uri -&gt; if (uri != null) viewModel.onImageUriChange(uri) }&#10;    )&#10;&#10;    val cameraLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.TakePicture(),&#10;        onResult = { success -&gt; if (success) viewModel.onImageUriChange(tempCameraUri) }&#10;    )&#10;&#10;    LaunchedEffect(imageUri, existingNote, isEncrypted) {&#10;        decryptedBitmap = null&#10;        if (isEncrypted &amp;&amp; existingNote?.imageFilename != null &amp;&amp; decryptedImageBytes != null) {&#10;            decryptedBitmap = BitmapFactory.decodeByteArray(decryptedImageBytes, 0, decryptedImageBytes!!.size)&#10;        } else when {&#10;            imageUri != null -&gt; {&#10;                withContext(Dispatchers.IO) {&#10;                    try {&#10;                        decryptedBitmap = BitmapFactory.decodeStream(context.contentResolver.openInputStream(imageUri!!))&#10;                    } catch (e: Exception) { e.printStackTrace() }&#10;                }&#10;            }&#10;            existingNote != null &amp;&amp; !existingNote!!.isEncrypted &amp;&amp; existingNote!!.imageFilename != null -&gt; {&#10;                withContext(Dispatchers.IO) {&#10;                    try {&#10;                        val bytes = context.openFileInput(existingNote!!.imageFilename!!).use { it.readBytes() }&#10;                        decryptedBitmap = BitmapFactory.decodeByteArray(bytes, 0, bytes.size)&#10;                    } catch (e: Exception) { e.printStackTrace() }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    val onSaveUnencryptedNote = {&#10;        coroutineScope.launch {&#10;            if (title.isBlank()) {&#10;                Toast.makeText(context, &quot;Title cannot be empty&quot;, Toast.LENGTH_SHORT).show()&#10;                return@launch&#10;            }&#10;&#10;            var finalImageFilename = existingNote?.imageFilename&#10;            if (imageUri != null) {&#10;                finalImageFilename = withContext(Dispatchers.IO) {&#10;                    val imageBytes = context.contentResolver.openInputStream(imageUri!!)?.use { it.readBytes() }&#10;                    if (imageBytes != null) {&#10;                        val newFilename = &quot;IMG_${UUID.randomUUID()}.jpg&quot;&#10;                        existingNote?.imageFilename?.let { context.deleteFile(it) }&#10;                        context.openFileOutput(newFilename, Context.MODE_PRIVATE).use { it.write(imageBytes) }&#10;                        newFilename&#10;                    } else { existingNote?.imageFilename }&#10;                }&#10;            }&#10;            val noteToSave = Note(&#10;                id = noteId ?: 0, title = title, content = content, isEncrypted = false, salt = null,&#10;                createdAt = existingNote?.createdAt ?: System.currentTimeMillis(),&#10;                updatedAt = System.currentTimeMillis(), imageFilename = finalImageFilename&#10;            )&#10;            if (isNewNote) viewModel.insert(noteToSave) else viewModel.update(noteToSave)&#10;            navController.popBackStack()&#10;        }&#10;    }&#10;&#10;    val onEncryptAndSave = { pin: String -&gt;&#10;        coroutineScope.launch {&#10;            if (title.isBlank()) {&#10;                Toast.makeText(context, &quot;Title cannot be empty&quot;, Toast.LENGTH_SHORT).show()&#10;                return@launch&#10;            }&#10;&#10;            val payload = EncryptionManager.encrypt(content, pin)&#10;            val encryptedContent = payload.encryptedData&#10;            val newSalt = payload.salt&#10;&#10;            // Only generate a new filename if a new image is picked&#10;            var finalImageFilename: String? = existingNote?.imageFilename&#10;            val imageToEncryptUri = imageUri ?: existingNote?.imageFilename?.let { Uri.fromFile(context.getFileStreamPath(it)) }&#10;&#10;            if (imageUri != null) {&#10;                finalImageFilename = withContext(Dispatchers.IO) {&#10;                    val imageBytes = context.contentResolver.openInputStream(imageUri!!)?.use { it.readBytes() }&#10;                    if (imageBytes != null) {&#10;                        val encryptedBytes = EncryptionManager.encryptBytes(imageBytes, pin, newSalt)&#10;                        val newFilename = &quot;IMG_${UUID.randomUUID()}.enc&quot;&#10;                        // Delete old image file if it exists&#10;                        existingNote?.imageFilename?.let { context.deleteFile(it) }&#10;                        if (encryptedBytes != null) {&#10;                            context.openFileOutput(newFilename, Context.MODE_PRIVATE).use { it.write(encryptedBytes) }&#10;                            newFilename&#10;                        } else null&#10;                    } else null&#10;                }&#10;            }&#10;            // If no new image is picked, keep the old filename&#10;&#10;            val noteToSave = Note(&#10;                id = noteId ?: 0, title = title, content = encryptedContent, isEncrypted = true, salt = newSalt,&#10;                createdAt = existingNote?.createdAt ?: System.currentTimeMillis(),&#10;                updatedAt = System.currentTimeMillis(), imageFilename = finalImageFilename&#10;            )&#10;            if (isNewNote) {&#10;                viewModel.insert(noteToSave)&#10;            } else {&#10;                viewModel.update(noteToSave)&#10;            }&#10;            // Reload note data to update existingNote and imageFilename&#10;            viewModel.loadNoteForEdit(noteId)&#10;            navController.popBackStack()&#10;        }&#10;    }&#10;&#10;    val onDecryptNote = { pin: String -&gt;&#10;        val currentNote = viewModel.editNoteExistingData.value&#10;        if (currentNote?.salt != null) {&#10;            val currentSalt = currentNote.salt&#10;            android.util.Log.d(&quot;NoteEditScreen&quot;, &quot;Decrypting with PIN: $pin, salt: $currentSalt&quot;)&#10;            val biometricManager = BiometricManager(context)&#10;            biometricManager.promptForAuthentication {&#10;                coroutineScope.launch {&#10;                    android.util.Log.d(&quot;NoteEditScreen&quot;, &quot;Starting decryption for noteId: ${currentNote.id}&quot;)&#10;                    val decryptedText = EncryptionManager.decrypt(currentNote.content, currentSalt, pin)&#10;                    android.util.Log.d(&quot;NoteEditScreen&quot;, &quot;Decrypted text: ${decryptedText?.take(50)}&quot;)&#10;                    if (decryptedText != null) {&#10;                        viewModel.onContentChange(decryptedText)&#10;                        isEncrypted = false&#10;                        val imageFilenameToDecrypt = currentNote.imageFilename&#10;                        android.util.Log.d(&quot;NoteEditScreen&quot;, &quot;Attempting to decrypt image file: $imageFilenameToDecrypt&quot;)&#10;                        imageFilenameToDecrypt?.let { filename -&gt;&#10;                            withContext(Dispatchers.IO) {&#10;                                try {&#10;                                    val encBytes = context.openFileInput(filename).use { it.readBytes() }&#10;                                    android.util.Log.d(&quot;NoteEditScreen&quot;, &quot;Read encrypted bytes: ${encBytes.size}&quot;)&#10;                                    val decBytes = EncryptionManager.decryptBytes(encBytes, pin, currentSalt)&#10;                                    if (decBytes != null) {&#10;                                        decryptedImageBytes = decBytes // Store decrypted bytes in state&#10;                                        withContext(Dispatchers.Main) {&#10;                                            decryptedBitmap = BitmapFactory.decodeByteArray(decBytes, 0, decBytes.size)&#10;                                            android.util.Log.d(&quot;NoteEditScreen&quot;, &quot;Set decryptedBitmap: ${decryptedBitmap != null}&quot;)&#10;                                            if (decryptedBitmap != null) {&#10;                                                android.util.Log.d(&quot;NoteEditScreen&quot;, &quot;Bitmap dimensions: ${decryptedBitmap!!.width}x${decryptedBitmap!!.height}&quot;)&#10;                                            }&#10;                                        }&#10;                                    } else {&#10;                                        android.util.Log.e(&quot;NoteEditScreen&quot;, &quot;Decryption failed: decBytes is null&quot;)&#10;                                        withContext(Dispatchers.Main) { decryptedBitmap = null }&#10;                                    }&#10;                                } catch (e: Exception) {&#10;                                    android.util.Log.e(&quot;NoteEditScreen&quot;, &quot;Exception during decryption&quot;, e)&#10;                                    withContext(Dispatchers.Main) { decryptedBitmap = null }&#10;                                }&#10;                            }&#10;                        }&#10;                        Toast.makeText(context, &quot;Note Decrypted!&quot;, Toast.LENGTH_SHORT).show()&#10;                    } else {&#10;                        android.util.Log.e(&quot;NoteEditScreen&quot;, &quot;Decryption failed: decryptedText is null&quot;)&#10;                        Toast.makeText(context, &quot;Incorrect PIN!&quot;, Toast.LENGTH_SHORT).show()&#10;                    }&#10;                }&#10;            }&#10;        } else {&#10;            android.util.Log.e(&quot;NoteEditScreen&quot;, &quot;Decryption failed: salt is null for noteId: ${currentNote?.id}&quot;)&#10;        }&#10;    }&#10;&#10;    if (showPinDialog) {&#10;        PinDialog(&#10;            action = pinAction,&#10;            onDismiss = { showPinDialog = false },&#10;            onConfirm = { pin -&gt;&#10;                showPinDialog = false&#10;                if (pinAction == PinAction.ENCRYPT) {&#10;                    onEncryptAndSave(pin)&#10;                } else {&#10;                    onDecryptNote(pin)&#10;                }&#10;            }&#10;        )&#10;    }&#10;&#10;    if (showDeleteDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { showDeleteDialog = false },&#10;            title = { Text(&quot;Delete Note&quot;) },&#10;            text = { Text(&quot;Are you sure you want to permanently delete this note?&quot;) },&#10;            confirmButton = {&#10;                TextButton(&#10;                    onClick = {&#10;                        viewModel.deleteById(noteId!!)&#10;                        showDeleteDialog = false&#10;                        Toast.makeText(context, &quot;Note Deleted&quot;, Toast.LENGTH_SHORT).show()&#10;                        navController.popBackStack()&#10;                    }&#10;                ) { Text(&quot;Confirm&quot;) }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = { showDeleteDialog = false }) { Text(&quot;Cancel&quot;) }&#10;            }&#10;        )&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(if (isNewNote) &quot;Add Note&quot; else &quot;Edit Note&quot;) },&#10;                navigationIcon = {&#10;                    IconButton(onClick = { navController.popBackStack() }) { Icon(Icons.Default.ArrowBack, contentDescription = &quot;Back&quot;) }&#10;                },&#10;                actions = {&#10;                    IconButton(onClick = {&#10;                        pinAction = if (isEncrypted) PinAction.DECRYPT else PinAction.ENCRYPT&#10;                        showPinDialog = true&#10;                    }) {&#10;                        Icon(&#10;                            imageVector = if (isEncrypted) Icons.Filled.LockOpen else Icons.Filled.Lock,&#10;                            contentDescription = if (isEncrypted) &quot;Decrypt Note&quot; else &quot;Encrypt Note&quot;&#10;                        )&#10;                    }&#10;                    if (!isNewNote) {&#10;                        IconButton(onClick = { showDeleteDialog = true }) { Icon(Icons.Default.Delete, contentDescription = &quot;Delete Note&quot;) }&#10;                    }&#10;                    IconButton(onClick = { onSaveUnencryptedNote() }) {&#10;                        Icon(Icons.Default.Check, contentDescription = &quot;Save Note&quot;)&#10;                    }&#10;                }&#10;            )&#10;        },&#10;    ) { paddingValues -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;                .padding(16.dp)&#10;                .verticalScroll(rememberScrollState())&#10;        ) {&#10;            OutlinedTextField(&#10;                value = title,&#10;                onValueChange = { viewModel.onTitleChange(it) },&#10;                label = { Text(&quot;Title&quot;) },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                singleLine = true,&#10;                readOnly = isEncrypted&#10;            )&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            OutlinedTextField(&#10;                value = content,&#10;                onValueChange = { viewModel.onContentChange(it) },&#10;                label = { Text(&quot;Content&quot;) },&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .heightIn(min = 150.dp),&#10;                readOnly = isEncrypted&#10;            )&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            Box(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                if (decryptedBitmap != null) {&#10;                    Image(&#10;                        bitmap = decryptedBitmap!!.asImageBitmap(),&#10;                        contentDescription = &quot;Selected Image&quot;,&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .aspectRatio(4f / 3f),&#10;                        contentScale = ContentScale.Crop&#10;                    )&#10;                } else if (isEncrypted &amp;&amp; existingNote?.imageFilename != null) {&#10;                    Icon(&#10;                        Icons.Filled.Lock,&#10;                        contentDescription = &quot;Encrypted Image&quot;,&#10;                        modifier = Modifier.size(128.dp)&#10;                    )&#10;                }&#10;            }&#10;&#10;            if (!isEncrypted) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(top = 8.dp),&#10;                    horizontalArrangement = Arrangement.Center,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Button(&#10;                        onClick = { photoPickerLauncher.launch(PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageOnly)) },&#10;                        modifier = Modifier.padding(end = 8.dp)&#10;                    ) {&#10;                        Icon(Icons.Default.PhotoLibrary, contentDescription = &quot;Add from Gallery&quot;)&#10;                        Spacer(Modifier.size(ButtonDefaults.IconSpacing))&#10;                        Text(&quot;Gallery&quot;)&#10;                    }&#10;                    Button(&#10;                        onClick = {&#10;                            val newUri = viewModel.createTempCameraUri(context)&#10;                            cameraLauncher.launch(newUri)&#10;                        },&#10;                        modifier = Modifier.padding(start = 8.dp)&#10;                    ) {&#10;                        Icon(Icons.Default.PhotoCamera, contentDescription = &quot;Take Photo&quot;)&#10;                        Spacer(Modifier.size(ButtonDefaults.IconSpacing))&#10;                        Text(&quot;Camera&quot;)&#10;                    }&#10;                }&#10;                Text(&#10;                    text = if (existingNote?.imageFilename == null &amp;&amp; imageUri == null) &quot;Add an Image&quot; else &quot;Change Image&quot;,&#10;                    modifier = Modifier.align(Alignment.CenterHorizontally).padding(top = 4.dp),&#10;                    style = MaterialTheme.typography.bodySmall&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private enum class PinAction { ENCRYPT, DECRYPT }&#10;&#10;@Composable&#10;private fun PinDialog(&#10;    action: PinAction,&#10;    onDismiss: () -&gt; Unit,&#10;    onConfirm: (String) -&gt; Unit&#10;) {&#10;    var pin by remember { mutableStateOf(&quot;&quot;) }&#10;    val title = if (action == PinAction.ENCRYPT) &quot;Set a 6-Digit PIN to Encrypt&quot; else &quot;Enter 6-Digit PIN&quot;&#10;    val buttonText = if (action == PinAction.ENCRYPT) &quot;Encrypt &amp; Save&quot; else &quot;Decrypt&quot;&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = { Text(title) },&#10;        text = {&#10;            OutlinedTextField(&#10;                value = pin,&#10;                onValueChange = { if (it.length &lt;= 6) pin = it.filter { c -&gt; c.isDigit() } },&#10;                label = { Text(&quot;PIN&quot;) },&#10;                singleLine = true,&#10;                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.NumberPassword),&#10;                visualTransformation = PasswordVisualTransformation()&#10;            )&#10;        },&#10;        confirmButton = {&#10;            Button(&#10;                onClick = { if (pin.length == 6) onConfirm(pin) },&#10;                enabled = pin.length == 6&#10;            ) { Text(buttonText) }&#10;        },&#10;        dismissButton = {&#10;            TextButton(onClick = onDismiss) { Text(&quot;Cancel&quot;) }&#10;        }&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="package co.uk.doverguitarteacher.securenotesaug20th&#10;&#10;import android.content.Context&#10;import android.graphics.Bitmap&#10;import android.graphics.BitmapFactory&#10;import android.net.Uri&#10;import android.widget.Toast&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.result.PickVisualMediaRequest&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.asImageBitmap&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.input.KeyboardType&#10;import androidx.compose.ui.text.input.PasswordVisualTransformation&#10;import androidx.compose.ui.unit.dp&#10;import androidx.core.content.FileProvider&#10;import androidx.fragment.app.FragmentActivity&#10;import androidx.navigation.NavController&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import java.io.File&#10;import java.util.UUID&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun NoteEditScreen(&#10;    navController: NavController,&#10;    viewModel: NoteViewModel,&#10;    noteId: Int?&#10;) {&#10;    val context = LocalContext.current as FragmentActivity&#10;    val coroutineScope = rememberCoroutineScope()&#10;    val isNewNote = noteId == null&#10;&#10;    val title by viewModel.editNoteTitle.collectAsState()&#10;    val content by viewModel.editNoteContent.collectAsState()&#10;    val imageUri by viewModel.editNoteImageUri.collectAsState()&#10;    val existingNote by viewModel.editNoteExistingData.collectAsState()&#10;    val tempCameraUri by viewModel.tempCameraImageUri.collectAsState()&#10;&#10;    var isEncrypted by remember(existingNote) { mutableStateOf(existingNote?.isEncrypted ?: false) }&#10;    var decryptedBitmap by remember { mutableStateOf&lt;Bitmap?&gt;(null) }&#10;    var showPinDialog by remember { mutableStateOf(false) }&#10;    var showDeleteDialog by remember { mutableStateOf(false) }&#10;    var pinAction by remember { mutableStateOf(PinAction.ENCRYPT) }&#10;&#10;    // Add a state to track decrypted image bytes&#10;    var decryptedImageBytes by remember { mutableStateOf&lt;ByteArray?&gt;(null) }&#10;&#10;    LaunchedEffect(Unit) {&#10;        viewModel.loadNoteForEdit(noteId)&#10;    }&#10;&#10;    val photoPickerLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.PickVisualMedia(),&#10;        onResult = { uri -&gt; if (uri != null) viewModel.onImageUriChange(uri) }&#10;    )&#10;&#10;    val cameraLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.TakePicture(),&#10;        onResult = { success -&gt; if (success) viewModel.onImageUriChange(tempCameraUri) }&#10;    )&#10;&#10;    LaunchedEffect(imageUri, existingNote, isEncrypted) {&#10;        decryptedBitmap = null&#10;        if (isEncrypted &amp;&amp; existingNote?.imageFilename != null &amp;&amp; decryptedImageBytes != null) {&#10;            decryptedBitmap = BitmapFactory.decodeByteArray(decryptedImageBytes, 0, decryptedImageBytes!!.size)&#10;        } else when {&#10;            imageUri != null -&gt; {&#10;                withContext(Dispatchers.IO) {&#10;                    try {&#10;                        decryptedBitmap = BitmapFactory.decodeStream(context.contentResolver.openInputStream(imageUri!!))&#10;                    } catch (e: Exception) { e.printStackTrace() }&#10;                }&#10;            }&#10;            existingNote != null &amp;&amp; !existingNote!!.isEncrypted &amp;&amp; existingNote!!.imageFilename != null -&gt; {&#10;                withContext(Dispatchers.IO) {&#10;                    try {&#10;                        val bytes = context.openFileInput(existingNote!!.imageFilename!!).use { it.readBytes() }&#10;                        decryptedBitmap = BitmapFactory.decodeByteArray(bytes, 0, bytes.size)&#10;                    } catch (e: Exception) { e.printStackTrace() }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    val onSaveUnencryptedNote = {&#10;        coroutineScope.launch {&#10;            if (title.isBlank()) {&#10;                Toast.makeText(context, &quot;Title cannot be empty&quot;, Toast.LENGTH_SHORT).show()&#10;                return@launch&#10;            }&#10;&#10;            var finalImageFilename = existingNote?.imageFilename&#10;            if (imageUri != null) {&#10;                finalImageFilename = withContext(Dispatchers.IO) {&#10;                    val imageBytes = context.contentResolver.openInputStream(imageUri!!)?.use { it.readBytes() }&#10;                    if (imageBytes != null) {&#10;                        val newFilename = &quot;IMG_${UUID.randomUUID()}.jpg&quot;&#10;                        existingNote?.imageFilename?.let { context.deleteFile(it) }&#10;                        context.openFileOutput(newFilename, Context.MODE_PRIVATE).use { it.write(imageBytes) }&#10;                        newFilename&#10;                    } else { existingNote?.imageFilename }&#10;                }&#10;            }&#10;            val noteToSave = Note(&#10;                id = noteId ?: 0, title = title, content = content, isEncrypted = false, salt = null,&#10;                createdAt = existingNote?.createdAt ?: System.currentTimeMillis(),&#10;                updatedAt = System.currentTimeMillis(), imageFilename = finalImageFilename&#10;            )&#10;            if (isNewNote) viewModel.insert(noteToSave) else viewModel.update(noteToSave)&#10;            navController.popBackStack()&#10;        }&#10;    }&#10;&#10;    val onEncryptAndSave = { pin: String -&gt;&#10;        coroutineScope.launch {&#10;            if (title.isBlank()) {&#10;                Toast.makeText(context, &quot;Title cannot be empty&quot;, Toast.LENGTH_SHORT).show()&#10;                return@launch&#10;            }&#10;&#10;            val payload = EncryptionManager.encrypt(content, pin)&#10;            val encryptedContent = payload.encryptedData&#10;            val newSalt = payload.salt&#10;&#10;            // Only generate a new filename if a new image is picked&#10;            var finalImageFilename: String? = existingNote?.imageFilename&#10;            val imageToEncryptUri = imageUri ?: existingNote?.imageFilename?.let { Uri.fromFile(context.getFileStreamPath(it)) }&#10;&#10;            if (imageUri != null) {&#10;                finalImageFilename = withContext(Dispatchers.IO) {&#10;                    val imageBytes = context.contentResolver.openInputStream(imageUri!!)?.use { it.readBytes() }&#10;                    if (imageBytes != null) {&#10;                        val encryptedBytes = EncryptionManager.encryptBytes(imageBytes, pin, newSalt)&#10;                        val newFilename = &quot;IMG_${UUID.randomUUID()}.enc&quot;&#10;                        // Only delete old image file if a new image is picked&#10;                        existingNote?.imageFilename?.let { context.deleteFile(it) }&#10;                        if (encryptedBytes != null) {&#10;                            context.openFileOutput(newFilename, Context.MODE_PRIVATE).use { it.write(encryptedBytes) }&#10;                            newFilename&#10;                        } else null&#10;                    } else null&#10;                }&#10;            } else if (existingNote?.imageFilename != null) {&#10;                // No new image picked, overwrite the existing file&#10;                withContext(Dispatchers.IO) {&#10;                    val imageFile = context.getFileStreamPath(existingNote.imageFilename!!)&#10;                    if (imageFile.exists()) {&#10;                        val encBytes = context.openFileInput(existingNote.imageFilename!!).use { it.readBytes() }&#10;                        val encryptedBytes = EncryptionManager.encryptBytes(encBytes, pin, newSalt)&#10;                        if (encryptedBytes != null) {&#10;                            context.openFileOutput(existingNote.imageFilename!!, Context.MODE_PRIVATE).use { it.write(encryptedBytes) }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            val noteToSave = Note(&#10;                id = noteId ?: 0, title = title, content = encryptedContent, isEncrypted = true, salt = newSalt,&#10;                createdAt = existingNote?.createdAt ?: System.currentTimeMillis(),&#10;                updatedAt = System.currentTimeMillis(), imageFilename = finalImageFilename&#10;            )&#10;            if (isNewNote) {&#10;                viewModel.insert(noteToSave)&#10;            } else {&#10;                viewModel.update(noteToSave)&#10;            }&#10;            // Reload note data to update existingNote and imageFilename&#10;            viewModel.loadNoteForEdit(noteId)&#10;            navController.popBackStack()&#10;        }&#10;    }&#10;&#10;    val onDecryptNote = { pin: String -&gt;&#10;        val currentNote = viewModel.editNoteExistingData.value&#10;        if (currentNote?.salt != null) {&#10;            val currentSalt = currentNote.salt&#10;            android.util.Log.d(&quot;NoteEditScreen&quot;, &quot;Decrypting with PIN: $pin, salt: $currentSalt&quot;)&#10;            val biometricManager = BiometricManager(context)&#10;            biometricManager.promptForAuthentication {&#10;                coroutineScope.launch {&#10;                    android.util.Log.d(&quot;NoteEditScreen&quot;, &quot;Starting decryption for noteId: ${currentNote.id}&quot;)&#10;                    val decryptedText = EncryptionManager.decrypt(currentNote.content, currentSalt, pin)&#10;                    android.util.Log.d(&quot;NoteEditScreen&quot;, &quot;Decrypted text: ${decryptedText?.take(50)}&quot;)&#10;                    if (decryptedText != null) {&#10;                        viewModel.onContentChange(decryptedText)&#10;                        isEncrypted = false&#10;                        val imageFilenameToDecrypt = currentNote.imageFilename&#10;                        android.util.Log.d(&quot;NoteEditScreen&quot;, &quot;Attempting to decrypt image file: $imageFilenameToDecrypt&quot;)&#10;                        imageFilenameToDecrypt?.let { filename -&gt;&#10;                            withContext(Dispatchers.IO) {&#10;                                try {&#10;                                    val encBytes = context.openFileInput(filename).use { it.readBytes() }&#10;                                    android.util.Log.d(&quot;NoteEditScreen&quot;, &quot;Read encrypted bytes: ${encBytes.size}&quot;)&#10;                                    val decBytes = EncryptionManager.decryptBytes(encBytes, pin, currentSalt)&#10;                                    if (decBytes != null) {&#10;                                        decryptedImageBytes = decBytes // Store decrypted bytes in state&#10;                                        withContext(Dispatchers.Main) {&#10;                                            decryptedBitmap = BitmapFactory.decodeByteArray(decBytes, 0, decBytes.size)&#10;                                            android.util.Log.d(&quot;NoteEditScreen&quot;, &quot;Set decryptedBitmap: ${decryptedBitmap != null}&quot;)&#10;                                            if (decryptedBitmap != null) {&#10;                                                android.util.Log.d(&quot;NoteEditScreen&quot;, &quot;Bitmap dimensions: ${decryptedBitmap!!.width}x${decryptedBitmap!!.height}&quot;)&#10;                                            }&#10;                                        }&#10;                                    } else {&#10;                                        android.util.Log.e(&quot;NoteEditScreen&quot;, &quot;Decryption failed: decBytes is null&quot;)&#10;                                        withContext(Dispatchers.Main) { decryptedBitmap = null }&#10;                                    }&#10;                                } catch (e: Exception) {&#10;                                    android.util.Log.e(&quot;NoteEditScreen&quot;, &quot;Exception during decryption&quot;, e)&#10;                                    withContext(Dispatchers.Main) { decryptedBitmap = null }&#10;                                }&#10;                            }&#10;                        }&#10;                        Toast.makeText(context, &quot;Note Decrypted!&quot;, Toast.LENGTH_SHORT).show()&#10;                    } else {&#10;                        android.util.Log.e(&quot;NoteEditScreen&quot;, &quot;Decryption failed: decryptedText is null&quot;)&#10;                        Toast.makeText(context, &quot;Incorrect PIN!&quot;, Toast.LENGTH_SHORT).show()&#10;                    }&#10;                }&#10;            }&#10;        } else {&#10;            android.util.Log.e(&quot;NoteEditScreen&quot;, &quot;Decryption failed: salt is null for noteId: ${currentNote?.id}&quot;)&#10;        }&#10;    }&#10;&#10;    if (showPinDialog) {&#10;        PinDialog(&#10;            action = pinAction,&#10;            onDismiss = { showPinDialog = false },&#10;            onConfirm = { pin -&gt;&#10;                showPinDialog = false&#10;                if (pinAction == PinAction.ENCRYPT) {&#10;                    onEncryptAndSave(pin)&#10;                } else {&#10;                    onDecryptNote(pin)&#10;                }&#10;            }&#10;        )&#10;    }&#10;&#10;    if (showDeleteDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { showDeleteDialog = false },&#10;            title = { Text(&quot;Delete Note&quot;) },&#10;            text = { Text(&quot;Are you sure you want to permanently delete this note?&quot;) },&#10;            confirmButton = {&#10;                TextButton(&#10;                    onClick = {&#10;                        viewModel.deleteById(noteId!!)&#10;                        showDeleteDialog = false&#10;                        Toast.makeText(context, &quot;Note Deleted&quot;, Toast.LENGTH_SHORT).show()&#10;                        navController.popBackStack()&#10;                    }&#10;                ) { Text(&quot;Confirm&quot;) }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = { showDeleteDialog = false }) { Text(&quot;Cancel&quot;) }&#10;            }&#10;        )&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(if (isNewNote) &quot;Add Note&quot; else &quot;Edit Note&quot;) },&#10;                navigationIcon = {&#10;                    IconButton(onClick = { navController.popBackStack() }) { Icon(Icons.Default.ArrowBack, contentDescription = &quot;Back&quot;) }&#10;                },&#10;                actions = {&#10;                    IconButton(onClick = {&#10;                        pinAction = if (isEncrypted) PinAction.DECRYPT else PinAction.ENCRYPT&#10;                        showPinDialog = true&#10;                    }) {&#10;                        Icon(&#10;                            imageVector = if (isEncrypted) Icons.Filled.LockOpen else Icons.Filled.Lock,&#10;                            contentDescription = if (isEncrypted) &quot;Decrypt Note&quot; else &quot;Encrypt Note&quot;&#10;                        )&#10;                    }&#10;                    if (!isNewNote) {&#10;                        IconButton(onClick = { showDeleteDialog = true }) { Icon(Icons.Default.Delete, contentDescription = &quot;Delete Note&quot;) }&#10;                    }&#10;                    IconButton(onClick = { onSaveUnencryptedNote() }) {&#10;                        Icon(Icons.Default.Check, contentDescription = &quot;Save Note&quot;)&#10;                    }&#10;                }&#10;            )&#10;        },&#10;    ) { paddingValues -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;                .padding(16.dp)&#10;                .verticalScroll(rememberScrollState())&#10;        ) {&#10;            OutlinedTextField(&#10;                value = title,&#10;                onValueChange = { viewModel.onTitleChange(it) },&#10;                label = { Text(&quot;Title&quot;) },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                singleLine = true,&#10;                readOnly = isEncrypted&#10;            )&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            OutlinedTextField(&#10;                value = content,&#10;                onValueChange = { viewModel.onContentChange(it) },&#10;                label = { Text(&quot;Content&quot;) },&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .heightIn(min = 150.dp),&#10;                readOnly = isEncrypted&#10;            )&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            Box(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                if (decryptedBitmap != null) {&#10;                    Image(&#10;                        bitmap = decryptedBitmap!!.asImageBitmap(),&#10;                        contentDescription = &quot;Selected Image&quot;,&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .aspectRatio(4f / 3f),&#10;                        contentScale = ContentScale.Crop&#10;                    )&#10;                } else if (isEncrypted &amp;&amp; existingNote?.imageFilename != null) {&#10;                    Icon(&#10;                        Icons.Filled.Lock,&#10;                        contentDescription = &quot;Encrypted Image&quot;,&#10;                        modifier = Modifier.size(128.dp)&#10;                    )&#10;                }&#10;            }&#10;&#10;            if (!isEncrypted) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(top = 8.dp),&#10;                    horizontalArrangement = Arrangement.Center,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Button(&#10;                        onClick = { photoPickerLauncher.launch(PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageOnly)) },&#10;                        modifier = Modifier.padding(end = 8.dp)&#10;                    ) {&#10;                        Icon(Icons.Default.PhotoLibrary, contentDescription = &quot;Add from Gallery&quot;)&#10;                        Spacer(Modifier.size(ButtonDefaults.IconSpacing))&#10;                        Text(&quot;Gallery&quot;)&#10;                    }&#10;                    Button(&#10;                        onClick = {&#10;                            val newUri = viewModel.createTempCameraUri(context)&#10;                            cameraLauncher.launch(newUri)&#10;                        },&#10;                        modifier = Modifier.padding(start = 8.dp)&#10;                    ) {&#10;                        Icon(Icons.Default.PhotoCamera, contentDescription = &quot;Take Photo&quot;)&#10;                        Spacer(Modifier.size(ButtonDefaults.IconSpacing))&#10;                        Text(&quot;Camera&quot;)&#10;                    }&#10;                }&#10;                Text(&#10;                    text = if (existingNote?.imageFilename == null &amp;&amp; imageUri == null) &quot;Add an Image&quot; else &quot;Change Image&quot;,&#10;                    modifier = Modifier.align(Alignment.CenterHorizontally).padding(top = 4.dp),&#10;                    style = MaterialTheme.typography.bodySmall&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private enum class PinAction { ENCRYPT, DECRYPT }&#10;&#10;@Composable&#10;private fun PinDialog(&#10;    action: PinAction,&#10;    onDismiss: () -&gt; Unit,&#10;    onConfirm: (String) -&gt; Unit&#10;) {&#10;    var pin by remember { mutableStateOf(&quot;&quot;) }&#10;    val title = if (action == PinAction.ENCRYPT) &quot;Set a 6-Digit PIN to Encrypt&quot; else &quot;Enter 6-Digit PIN&quot;&#10;    val buttonText = if (action == PinAction.ENCRYPT) &quot;Encrypt &amp; Save&quot; else &quot;Decrypt&quot;&#10;&#10;    AlertDialog(&#10;        onDismissRequest = onDismiss,&#10;        title = { Text(title) },&#10;        text = {&#10;            OutlinedTextField(&#10;                value = pin,&#10;                onValueChange = { if (it.length &lt;= 6) pin = it.filter { c -&gt; c.isDigit() } },&#10;                label = { Text(&quot;PIN&quot;) },&#10;                singleLine = true,&#10;                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.NumberPassword),&#10;                visualTransformation = PasswordVisualTransformation()&#10;            )&#10;        },&#10;        confirmButton = {&#10;            Button(&#10;                onClick = { if (pin.length == 6) onConfirm(pin) },&#10;                enabled = pin.length == 6&#10;            ) { Text(buttonText) }&#10;        },&#10;        dismissButton = {&#10;            TextButton(onClick = onDismiss) { Text(&quot;Cancel&quot;) }&#10;        }&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>